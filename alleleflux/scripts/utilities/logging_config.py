"""Centralized logging configuration utilities for AlleleFlux.

This module exposes a single function, `setup_logging`, that configures a
reasonably safe and consistent application-wide logging setup using
`logging.config.dictConfig`.

Behavior highlights:
- ISOLATION: Configures only the 'alleleflux' logger, preventing interference
  with Snakemake or other tools running in the same process.
- Honors the `ALLELEFLUX_LOG_LEVEL` environment variable when present.
- Accepts either numeric levels (e.g., "20") or level names (e.g., "INFO").
- Emits a concise warning to stderr and falls back to INFO on invalid values.
- Supports colored output for different log levels when terminal supports it.
"""

import logging
import logging.config
import os
import sys
from typing import Union


class ColoredFormatter(logging.Formatter):
    """Custom formatter that adds ANSI color codes to log levels."""

    # ANSI color codes for terminal output
    COLORS = {
        "DEBUG": "\033[36m",  # Cyan
        "INFO": "\033[37m",  # White (default)
        "WARNING": "\033[33m",  # Yellow
        "ERROR": "\033[31m",  # Red
        "CRITICAL": "\033[35m",  # Magenta
    }
    RESET = "\033[0m"  # Reset color code

    def __init__(self, *args, use_color=None, **kwargs):
        super().__init__(*args, **kwargs)
        # Auto-detect color support if not explicitly set by the user
        if use_color is None:
            # Check if we're outputting to a terminal (TTY) that supports colors
            # and that the user hasn't explicitly requested no color via env vars.
            self.use_color = (
                hasattr(sys.stderr, "isatty")
                and sys.stderr.isatty()
                and os.getenv("TERM") != "dumb"
                and os.getenv("NO_COLOR") is None
            )
        else:
            self.use_color = use_color

    def format(self, record):
        """Format the specified record as text, adding color codes if enabled."""
        # Get the original formatted message based on the format string
        message = super().format(record)

        if self.use_color:
            # Add color to the level name (e.g., [INFO]) in the message
            level_name = record.levelname
            if level_name in self.COLORS:
                # Replace the plain level name with the colored version
                colored_level = f"{self.COLORS[level_name]}{level_name}{self.RESET}"
                message = message.replace(f"[{level_name}]", f"[{colored_level}]")

        return message


def setup_logging(
    level: Union[int, str] = logging.INFO, use_color: bool = None
) -> None:
    """Configure the 'alleleflux' logger via dictConfig.

    This setup ensures that logs generated by the alleleflux library are formatted
    correctly, while logs from other libraries (like Snakemake) are left untouched.

    Parameters
    ----------
    level : int | str, optional
        Default logging level to use when the `ALLELEFLUX_LOG_LEVEL` environment
        variable is not set. Can be an integer (e.g., ``logging.INFO`` or ``20``)
        or a case-insensitive level name such as ``"INFO"`` or ``"debug"``.
    use_color : bool, optional
        Whether to use colored output. If None (default), auto-detects based on
        terminal capabilities.
    """
    # Idempotency check: skip if already configured
    # This prevents reconfiguring logging when called multiple times
    alleleflux_logger = logging.getLogger("alleleflux")
    if alleleflux_logger.handlers:
        return  # Already configured

    # 1. Determine Log Level
    # Read level from environment if provided, falling back to the default `level`.
    raw = os.getenv("ALLELEFLUX_LOG_LEVEL", str(level)).strip()

    # Robustly coerce the level:
    # - Numeric strings ("20") -> int
    # - Names ("INFO") -> logging constants
    # - Invalid -> Fallback to INFO
    try:
        eff_level = int(raw)
    except ValueError:
        eff_level = getattr(logging, raw.upper(), None)
        if not isinstance(eff_level, int):
            print(f"Warning: Invalid log level '{raw}', using INFO.", file=sys.stderr)
            eff_level = logging.INFO

    # 2. Define Configuration Dictionary
    config = {
        "version": 1,
        # IMPORTANT: Keep existing loggers (like Snakemake's) alive.
        # If True, this would silence everything else in the python process.
        "disable_existing_loggers": False,
        "formatters": {
            "colored": {
                "()": ColoredFormatter,
                "format": "%(asctime)s [%(levelname)s] %(name)s: %(message)s",
                "datefmt": "%Y-%m-%d %H:%M:%S",
                "use_color": use_color,
            },
            # A fallback formatter if colors are disabled
            "plain": {
                "format": "%(asctime)s [%(levelname)s] %(name)s: %(message)s",
                "datefmt": "%Y-%m-%d %H:%M:%S",
            },
        },
        "handlers": {
            "console": {
                "class": "logging.StreamHandler",
                "formatter": "colored",
                # Write to stderr so that stdout can be used for piping data if needed
                "stream": "ext://sys.stderr",
            }
        },
        # 3. Logger Configuration
        # We DO NOT configure "root" here. Configuring root affects Snakemake.
        # Instead, we configure only the logger matching our package name.
        "loggers": {
            "alleleflux": {
                "handlers": ["console"],
                "level": eff_level,
                # CRITICAL: propagate=False
                # This prevents logs from bubbling up to the Root logger.
                # Since Snakemake attaches its handler to Root, this ensures
                # our logs are NOT printed a second time by Snakemake.
                "propagate": False,
            },
        },
    }

    # 4. Apply Configuration
    # This applies the settings above. Any logger created with
    # logging.getLogger("alleleflux") or logging.getLogger("alleleflux.submodule")
    # will now use this configuration.
    logging.config.dictConfig(config)

    # Log a confirmation message to the specific alleleflux logger
    logging.getLogger("alleleflux").info(
        f"Logging configured with level: {logging.getLevelName(eff_level)}"
    )
